type Uniswap @entity {
  # factory address
  id: ID!

  pairs: [Pair]!
  pairCount: Int!
}

type Token @entity {
  # token address
  id: ID!

  # mirrored from the smart contract
  name: String
  symbol: String
  decimals: Int

  pairs: [Pair]!
  WETHPair: Pair
}

type Pair @entity {
  # pair address
  id: ID!
  factory: Uniswap! @derivedFrom(field: "pairs")

  # mirrored from the smart contract
  token0: Token!
  token1: Token!
  reserve0: BigDecimal!
  reserve1: BigDecimal!
  totalSupply: BigDecimal!

  # creation stats
  createdAtBlockNumber: BigInt!
  createdAtTimestamp: BigInt!

  # lifetime volume stats
  volumeToken0: BigDecimal!
  volumeToken1: BigDecimal!
}

type Transaction @entity {
  id: ID! # transaction hash
  blockNumber: BigInt!
  timestamp: BigInt!
  mints: [Mint]!
  burns: [Burn]!
  swaps: [Swap]!
}

type Mint implements Event @entity {
  # transaction hash + "-" + index in mints Transaction array
  id: ID!
  transaction: Transaction! @derivedFrom(field: "mints")

  pair: Pair!

  # populated from the primary Transfer event
  to: Bytes!
  liquidity: BigDecimal!

  # populated from the Mint event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type Burn implements Event @entity {
  # transaction hash + "-" + index in burns Transaction array
  id: ID!
  transaction: Transaction! @derivedFrom(field: "burns")

  pair: Pair

  # populated from the primary Transfer event
  liquidity: BigDecimal!

  # populated from the Burn event
  sender: Bytes
  amount0: BigDecimal
  amount1: BigDecimal
  to: Bytes

  # optional fee fields, if a Transfer event is fired in _mintFee
  feeTo: Bytes
  feeLiquidity: BigDecimal
}

type Swap implements Event @entity {
  # transaction hash + "-" + index in swaps Transaction array
  id: ID!
  transaction: Transaction! @derivedFrom(field: "swaps")

  pair: Pair

  # populated from the Swap event
  sender: Bytes!
  amount0In: BigDecimal!
  amount1In: BigDecimal!
  amount0Out: BigDecimal!
  amount1Out: BigDecimal!
  to: Bytes!
}

# # stores for USD calculations
# type Bundle @entity {
#   id: ID!
#   ethPrice: BigDecimal! # price of ETH usd
#   # daiPrice: BigDecimal! # price of ETH in DAI

#   # add these later
#   # USDC: BigDecimal! # price of ETH is usdc
#   # TUSD: BigDecimal! # price of ETH in TUSD
# }

# # Data checkpointed at each event
# type UniswapHistoricalData @entity {
#   id: ID! # unique based on incremental entity count, one for each transactions
#   timestamp: Int!
#   totalVolumeUSD: BigDecimal!
#   totalVolumeETH: BigDecimal!
#   totalLiquidityUSD: BigDecimal!
#   totalLiquidityETH: BigDecimal!
#   txCount: BigInt!
# }

# # Data accumulated and condensed into day stats for all of Uniswap
# type UniswapDayData @entity {
#   id: ID!
#   # timestamp rounded to current day by dividing by 86400 - should only be one per day
#   date: Int!

#   dailyVolumeUSD: BigDecimal!
#   dailyVolumeETH: BigDecimal!

#   totalVolumeETH: BigDecimal!
#   totalVolumeUSD: BigDecimal!

#   totalLiquidityUSD: BigDecimal!
#   totalLiquidityETH: BigDecimal!

#   # daily top tokens in liquidity
#   maxStored: Int!
#   mostLiquidTokens: [TokenDayData!]!

#   txCount: BigInt!
# }

# enum EventType {
#   mint
#   burn
#   swap
# }

# type ExchangeHistoricalData @entity {
#   id: ID!
#   exchangeAddress: Bytes!
#   type: EventType!
#   timestamp: Int!

#   # liquidity
#   token0Balance: BigDecimal!
#   token1Balance: BigDecimal!
#   combinedBalanceUSD: BigDecimal!
#   combinedBalanceETH: BigDecimal!
#   totalUniToken: BigDecimal!

#   # volume
#   tradeVolumeToken0: BigDecimal!
#   tradeVolumeToken1: BigDecimal!
#   tradeVolumeETH: BigDecimal!
#   tradeVolumeUSD: BigDecimal!

#   # pricing
#   token0Price: BigDecimal!
#   token1Price: BigDecimal!

#   # txns
#   totalTxsCount: BigInt!
# }

# # Data accumulated and condensed into day stats for each exchange
# type ExchangeDayData @entity {
#   id: ID!
#   date: Int!
#   exchangeAddress: Bytes!
#   token0: Token!
#   token1: Token!
#   token0Balance: BigDecimal!
#   token1Balance: BigDecimal!
#   combinedBalanceETH: BigDecimal!
#   combinedBalanceUSD: BigDecimal!
#   dailyVolumeToken0: BigDecimal!
#   dailyVolumeToken1: BigDecimal!
#   dailyVolumeUSD: BigDecimal!
#   dailyTxns: BigInt!
# }

# type UserExchangeData @entity {
#   # ID is concatenation of exchange addr and user addr. i.e. 0xahiow4-0xkashkd34....
#   id: ID!
#   userAddress: Bytes!
#   user: User!
#   pair: Pair!

#   # token0 info
#   token0Deposited: BigDecimal!
#   token0Withdrawn: BigDecimal!

#   # token1 info
#   token1Deposited: BigDecimal!
#   token1Withdrawn: BigDecimal!

#   # balance of lp shares for this exchange
#   uniTokenBalance: BigDecimal!

#   # swapping data
#   token0Bought: BigDecimal!
#   token0Sold: BigDecimal!
#   token1Bought: BigDecimal!
#   token1Sold: BigDecimal!
# }

# type TokenHistoricalData @entity {
#   id: ID!
#   token: Token!
#   timestamp: Int!

#   # volume
#   tradeVolumeToken: BigDecimal!
#   tradeVolumeETH: BigDecimal!
#   tradeVolumeUSD: BigDecimal!

#   totalLiquidityToken: BigDecimal!
#   totalLiquidityETH: BigDecimal!
#   totalLiquidityUSD: BigDecimal!

#   # pricing
#   priceETH: BigDecimal
#   priceUSD: BigDecimal
# }

# # Data accumulated and condensed into day stats for each token across all pairs
# type TokenDayData @entity {
#   id: ID!
#   date: Int!
#   token: Token!

#   # volume state
#   dailyVolumeToken: BigDecimal!
#   dailyVolumeETH: BigDecimal!
#   dailyVolumeUSD: BigDecimal!

#   # liquidity stats
#   totalLiquidityToken: BigDecimal!
#   totalLiquidityETH: BigDecimal!
#   totalLiquidityUSD: BigDecimal!

#   dailyTxns: BigInt!

#   # top pairs that this token is in by liquidity
#   maxStored: Int!
#   mostLiquidPairs: [ExchangeDayData!]!
# }

# type User @entity {
#   # user eth address
#   id: ID!
#   # all exhanges user has shares within
#   exchangeBalances: [UserExchangeData!]! @derivedFrom(field: "user")
# }
